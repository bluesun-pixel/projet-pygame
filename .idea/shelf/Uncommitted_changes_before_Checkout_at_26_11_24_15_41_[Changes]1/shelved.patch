Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># <editor-fold desc=\"Initialisation et variables générales\">\nimport pygame\nfrom pygame.locals import *\nimport math\nimport random\nfrom random import randint\n\n# Initiation de pygame et de la fenêtre de jeu\npygame.init()\npygame.key.set_repeat(30, 30)\nfenetre = pygame.display.set_mode((1280, 649), RESIZABLE)\nliste_sprite = pygame.sprite.LayeredUpdates()\n\n\n# </editor-fold>\n\n# <editor-fold desc=\"Fonctions générales liées à pygame et à la structure du jeu\">\n# Fonction permettant d'ajouter un sprite automatiquement dans le LayeredUpdate\ndef ajouter_sprite(image_nom, rect_x, rect_y):\n    sprite_ajout = pygame.sprite.Sprite()\n    pygame.sprite.Sprite.__init__(sprite_ajout)\n    sprite_ajout.image = pygame.image.load(image_nom).convert()\n    sprite_ajout.rect = sprite_ajout.image.get_rect()\n    sprite_ajout.rect.x = rect_x\n    sprite_ajout.rect.y = rect_y\n    liste_sprite.add(sprite_ajout)\n    return sprite_ajout\n\n# Fonction permettant d'ajouter du texte automatiquement dans le LayeredUpdate\ndef ajouter_texte(police_nom, taille, texte_a_afficher):\n    police = pygame.font.Font(police_nom, taille)\n    texte = pygame.sprite.Sprite()\n    pygame.sprite.Sprite.__init__(texte)\n    liste_sprite.add(texte)\n\n    texte.image = police.render(texte_a_afficher, 1, (10, 10, 10), (255, 90, 20))\n    texte.rect = texte.image.get_rect()\n    texte.rect.centerx = fenetre.get_rect().centerx\n    texte.rect.centery = fenetre.get_rect().centery\n    liste_sprite.add(texte)\n    return texte\n\n#fonction retournant la distance entre 2 points grâce à Pythagore\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n#fonction permettant de générer n points uniformément sur une certaine surface, en respectant une distance minimum\ndef poisson_disc_sampling(distance_minimum, hauteur, largeur, k=50):\n    points = []\n    taille_de_grille = distance_minimum / math.sqrt(2)\n    largeur_de_grille = math.ceil(largeur / taille_de_grille)\n    hauteur_de_grille = math.ceil(hauteur / taille_de_grille)\n    grille = [[None for _ in range(hauteur_de_grille)] for _ in range(largeur_de_grille)]\n\n    def est_contenu_dans_la_fenetre(x, y):\n        return 0 <= x < largeur and 0 <= y < hauteur\n\n    def est_valable(point):\n        gx = int(point[0] / taille_de_grille)\n        gy = int(point[1] / taille_de_grille)\n\n        for i in range(-2, 3):\n            for j in range(-2, 3):\n                x_voisin = gx + i\n                y_voisin = gy + j  # Fix here, should be gy + j instead of gy + i\n                if 0 <= x_voisin < largeur_de_grille and 0 <= y_voisin < hauteur_de_grille:\n                    voisin = grille[x_voisin][y_voisin]\n                    if voisin and distance(point, voisin) < distance_minimum:\n                        return False\n        return True\n\n    def ajouter_point(point):\n        points.append(point)\n        gx = int(point[0] / taille_de_grille)\n        gy = int(point[1] / taille_de_grille)\n        grille[gx][gy] = point\n\n    liste_active = []\n    point_initial = (random.uniform(0, largeur), random.uniform(0, hauteur))\n    ajouter_point(point_initial)\n    liste_active.append(point_initial)\n\n    while liste_active:\n        point_actuel = random.choice(liste_active)\n        trouve = False\n\n        for i in range(k):\n            angle = random.uniform(0, math.pi * 2)\n            rayon = random.uniform(distance_minimum, 2 * distance_minimum)\n            nouveau_point = (point_actuel[0] + rayon * math.cos(angle), point_actuel[1] + rayon * math.sin(angle))\n\n            if est_contenu_dans_la_fenetre(*nouveau_point) and est_valable(nouveau_point):\n                ajouter_point(nouveau_point)\n                liste_active.append(nouveau_point)\n                trouve = True\n                break\n        if not trouve:\n            liste_active.remove(point_actuel)\n\n    return points\n# </editor-fold>\n\n# <editor-fold desc=\"Déclaration des classes\">\n# Classe parente dont les obstacles héritent\nclass Obstacles:\n    def __init__(self, pos_x, pos_y):\n        self.pos_x = pos_x\n        self.pos_y = pos_y\n\n    # Réaction générale des obstacles à une collision --> effet sur la balle de façon générale\n    def collision(self, balle):\n        pass\n\n# Classe définissant l'obstacle arbre, faisant rebondir la balle\nclass Arbre(Obstacles):\n    def __init__(self, pos_x, pos_y):\n        super().__init__(pos_x, pos_y)\n        self.nom_image = \"Images/img_2.png\"\n        #ajouter_sprite(self.nom_image, pos_x, pos_y)\n\n    # Override de la fonction collision() du parent\n    def collision(self, balle):\n        super().collision(balle)\n        print(\"Une balle est rentrée dans l'arbre!\")\n\n# Classe définissant les bunkers (sable)\nclass Bunker(Obstacles):\n    def __init__(self, pos_x, pos_y):\n        super().__init__(pos_x, pos_y)\n        self.nom_image = \"Images/img.png\"\n        #ajouter_sprite(self.nom_image, pos_x, pos_y)\n\n    # Override de la fonction collision() du parent\n    def collision(self, balle):\n        super().collision(balle)\n        print(\"Oh non! Un bunker!\")\n\n# </editor-fold>\n\n# <editor-fold desc=\"Déclaration et définitions des constantes/variables spécifiques\">\n#définition des constantes du jeu\nNOMBRE_DE_POINTS = 70\nPHI = 1.618\nRAYON = 350\nNOMBRE_ARBRES = 20\nNOMBRE_BUNKERS = 20\nDISTANCE_MINIMUM_TEE_DRAPEAU = 800\nVITESSE_ANGULAIRE = .002\n\n#défintion des variables et instances de classe\nobstacle1 = Obstacles(0, 0)  # TODO: essayer de créer une classe abstraite/virtuelle\npoints = poisson_disc_sampling(90, 649, 1280, 50)\nalpha = 0 #angle en degré représentant la direction de visée\n\n# </editor-fold>\n\n# <editor-fold desc=\"Fonctions spécifiques au jeu\">\n# Fonction générant le terrain basé sur une liste de points\ndef generation_du_terrain(liste_de_points):\n    arbres = []\n    if NOMBRE_ARBRES <= len(liste_de_points):\n        for i in range(NOMBRE_ARBRES):\n            index = randint(0, len(liste_de_points) - 1)\n            x_pos, y_pos = liste_de_points[index]\n            arbre_instance = Arbre(x_pos, y_pos)\n            arbres.append(arbre_instance)\n            liste_de_points.remove(liste_de_points[index])\n    else:\n        print(\"More obstacles are instanced than there are points available.\")\n\n    bunkers = []\n    if NOMBRE_BUNKERS <= len(liste_de_points):\n        for i in range(NOMBRE_BUNKERS):\n            index = randint(0, len(liste_de_points) - 1)\n            x_pos, y_pos = liste_de_points[index]\n            bunker_instance = Bunker(x_pos, y_pos)\n            bunkers.append(bunker_instance)\n            liste_de_points.remove(liste_de_points[index])\n    else:\n        print(\"More obstacles are instanced than there are points available.\")\n\n    drapeau_index = randint(0, len(liste_de_points) - 1)\n    drapeau = liste_de_points[drapeau_index]\n    liste_de_points.remove(liste_de_points[drapeau_index])\n\n    tee_index = randint(0, len(liste_de_points) - 1)\n    tee = liste_de_points[tee_index]\n    liste_de_points.remove(liste_de_points[tee_index])\n\n    optimal_distance = distance(tee, drapeau)\n    while optimal_distance < DISTANCE_MINIMUM_TEE_DRAPEAU and len(liste_de_points) >2:\n        tee_index_prime = randint(0, len(liste_de_points) - 1)\n        tee_prime = liste_de_points[tee_index_prime]\n        new_distance = distance(tee_prime, drapeau)\n        if new_distance > optimal_distance:\n            tee_index = tee_index_prime\n            tee = tee_prime\n            optimal_distance = new_distance\n        else:\n            print(\"point discarded\")\n        liste_de_points.remove(liste_de_points[tee_index_prime])\n\n    return arbres, bunkers, drapeau, tee\n\n# </editor-fold>\n\n# <editor-fold desc=\"Initialisation du jeu\">\nterrain = ajouter_sprite(\"Images/grass_texture.jpg\", 0, 0)\n\nliste_arbres, liste_bunkers, drapeau_position, tee_position = generation_du_terrain(points)\ncontinuer = True\n# </editor-fold>\n\n# <editor-fold desc=\"Boucle de jeu\">\nwhile continuer:\n    liste_sprite.draw(fenetre)\n\n    for point in points:\n        pygame.draw.circle(fenetre, (100, 100, 100), (int(point[0]), int(point[1])), 10)\n    for arbre in liste_arbres:\n        pygame.draw.circle(fenetre, (0, 255, 100), (int(arbre.pos_x), int(arbre.pos_y)), 25)\n    for bunker in liste_bunkers:\n        pygame.draw.circle(fenetre, (194, 178, 128), (int(bunker.pos_x), int(bunker.pos_y)), 25)\n    pygame.draw.circle(fenetre, (255, 0, 0), (int(drapeau_position[0]), int(drapeau_position[1])), 25)\n    pygame.draw.circle(fenetre, (0, 0, 190), (int(tee_position[0]), int(tee_position[1])), 25)\n\n    if alpha < 360:\n        alpha += VITESSE_ANGULAIRE\n    else:\n        alpha = 0\n\n    visee_x = tee_position[0] + math.cos(alpha) * 50\n    visee_y = tee_position[1] + math.sin(alpha) * 50\n\n    pygame.draw.circle(fenetre, (0, 0, 190), (int(visee_x), visee_y), 10)\n\n\n    pygame.display.flip()\n\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            continuer = False\n# </editor-fold>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 0e3185c2f684813e3d8e987ad51a6db30c7e7e17)
+++ b/main.py	(date 1732632085782)
@@ -1,5 +1,6 @@
 # <editor-fold desc="Initialisation et variables générales">
 import pygame
+from pygame.examples.cursors import image
 from pygame.locals import *
 import math
 import random
@@ -234,6 +235,7 @@
 
     pygame.draw.circle(fenetre, (0, 0, 190), (int(visee_x), visee_y), 10)
 
+    pygame.sprite.spritecollide()
 
     pygame.display.flip()
 
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"Black\">\n    <option name=\"sdkName\" value=\"Python 3.12 (projet-pygame)\" />\n  </component>\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.12 (projet-pygame)\" project-jdk-type=\"Python SDK\" />\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 0e3185c2f684813e3d8e987ad51a6db30c7e7e17)
+++ b/.idea/misc.xml	(date 1732630385118)
@@ -3,5 +3,5 @@
   <component name="Black">
     <option name="sdkName" value="Python 3.12 (projet-pygame)" />
   </component>
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.12 (projet-pygame)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.12 (Projets)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
